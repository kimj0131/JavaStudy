
public class A05_TypeCasting {

	/*
	 	# 타입 캐스팅
	 	
	 	 - 타입 캐스팅에는 명시하지 않아도 타입이 자동으로 변하는 '자동 타입 캐스팅'과
	 	   데이터의 타입을 강제로 변환하는 '강제 타입 캐스팅'이 있다.
	 	 - 데이터 또는 변수 앞에 (타입)을 적으면 타입이 강제로 변한다.
	 	 
	 	# 자동 타입 캐스팅
	 	 - 작은 타입에서 큰 타입으로 변하는 경우
	 	 - 그 외 타입이 변하더라도 특별히 문제가 발생하지 않는 경우
	 	 - 값이 손상될 우려가 없는 자연스러운 경우
	 	 
	 	# 강제 타입 캐스팅
	 	 - 큰 타입의 값을 작은 타입에 억지로 넣어야 하는 경우
	 	 - 그 외 타입이 변했을 때 특정 기능이 손실될 수 있는 경우 (short > char, char > short)
	 	 - 값이 손상될 우려가 있어서 프로그래머에게 에러로 알려야 하는 경우 권장시킴
	 	 
	 	# 타입의 크기 순서
	 														*소수가 더 큰 판정이다.*
	 	 byte(1) < short(2), char(2) < int (4) < long(8) < float(4) < double(8)
	 	 
	 	 - 작은 타입의 값을 큰 타입 변수에 넣을때는 아무런 문제도 발생하지 않는다
	 	 - 큰 타입의 값을 작은 타입 변수에 넣을떄는 위험하다면서 에러가 발생한다.
	*/
	public static void main(String[] args) {
		
		// 작은 타입의 값을 큰 타입에 넣기(정상 작동)
		// 자동으로 byte타입 값을 int타입으로 변환하여 넣어줌 (자동 타입 캐스팅)
		byte b = 127;
		int i = b;		// -> int i = (int)b; 타입캐스팅을 작성하지않아도 자동 변환됨
		
		System.out.println(i);
		
		// 큰 타입의 값을 작은 타입에 넣기
		// int타입 정수 값을 강제로 byte타입으로 변환하여 넣음(강제 타입 캐스팅)
		
		/*
		 	 int i2 = 130의 메모리 할당
		 	00000000 00000000 00000000 10000010
		 	> 강제 타입캐스팅
		 	 byte b2 
		 	10000010  -> 1111101 + 1
		 	메모리의 할당된 공간중 맨 왼쪽 한자리를 sign bit(부호비트)로 판단
		 	
		 	부호비트가 0일때는 나머지 값을 양수 값이라고 생각한다.
		 	부호비트가 1일때는 나머지 값의 2의 보수를 음수값이라고 생각한다.
		 	* 2의 보수 : 0, 1 을 뒤집고 + 1을 한 값
		 	==> -126으로 출력
		*/
		int i2 = 130;
		byte b2 = (byte)i2;
		
		System.out.println("강제로 짤린 i2의 결과 : "+ b2);	// 오버플로우
		
		// long은 8바이트고 float은 4바이트지만 소수를 더 큰것으로 간주한다. >> 정상적으로 자동 타입 캐스팅이 됨
		long l1 = 1000000000L;
		float f1 = l1;
		
		System.out.println(f1);
		
		// short, char 모두 2byte이지만 
		// short에는 음수값이 존재할 위험이 있으므로 확인(강제 타입캐스팅)이 필요하다.
		short s1 = 70;
		char ch1 = (char)s1;		//자동이 에러가 나는 경우 : 두 타입의 값의 범위가 달라 손실될 수 있으므로 에러메시지를 띄움
		
		System.out.println(ch1);
		
		// char에서 short로 갈때도 32767 이상의 양수가 포함되어 있을 가능성이 있으므로
		// 강제 타입캐스팅을 통한 확인이 필요하다.
		char ch2 = 'F';
		short s2 = (short)ch2;
		System.out.println(s2);
		
		// 해당 값의 문자 형태를 보고 싶은 경우
		// 타입 캐스팅을 사용해 간편하게 확인할 수 있다.
		int value = 44033;
		
		System.out.println(value);
		System.out.println((char)value);
	}
}
